# Checks out the full repository and ensures links to all files in the branch work, even for files not part of the current commit.
name: Biome CI - Lint, Format & Sort Imports report

on:
  workflow_dispatch:
  push:

permissions:
  contents: read

jobs:
  biome:
    name: Biome Lint & Format
    if: github.repository != 'tmfg/digitraffic-cdk'
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      # 1. Checkout full repo
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0  # fetch full history so all files exist
          ref: ${{ github.ref }} # ensure the branch tip is checked out

      - name: Set Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 22

      - name: Setup Biome
        uses: biomejs/setup-biome@v2
        with:
          version: latest

      - name: Run Biome per subdirectory
        run: |
          mkdir -p reports
          ROOT_DIRS="aviation marine other rail road"

          for ROOT in $ROOT_DIRS; do
            echo "::group::Scanning $ROOT"

            # find subdirectories (only dirs, no files)
            SUBDIRS=$(find "$ROOT" -mindepth 1 -maxdepth 1 -type d 2>/dev/null || true)

            if [ -z "$SUBDIRS" ]; then
              echo "No subdirectories in $ROOT"
              echo "::endgroup::"
              continue
            fi

            for SUB in $SUBDIRS; do
              echo "### Running Biome in $SUB"
              biome ci "$SUB" --reporter=github --no-errors-on-unmatched 2>&1 \
                | tee -a "reports/biome-gh.txt"
            done

            echo "::endgroup::"
          done

      - name: Parse Biome GitHub annotations & generate Markdown
        run: |
          node <<'EOF'
          const fs = require('fs');

          // Get the branch name (HEAD_REF if triggered by PR, otherwise REF_NAME)
          const branch = process.env.GITHUB_HEAD_REF || process.env.GITHUB_REF_NAME || 'master';
          const repo = process.env.GITHUB_REPOSITORY;

          const ROOT_DIRS = ['aviation','marine','other','rail','road'];

          // Icons used in the report for each severity level
          const levelIcon = {
            notice: 'ℹ️',
            warning: '⚠️',
            error: '❌'
          };

          // Read raw Biome GitHub annotation output
          const raw = fs.readFileSync('reports/biome-gh.txt','utf8');

          // Regex to parse GitHub workflow annotation lines generated by Biome
          const regex = /^::(notice|warning|error) title=([^,]+),file=([^,]+),line=(\d+),endLine=(\d+),col=(\d+),endColumn=(\d+)::(.*)$/gm;

          let m, annotations = [];
          while ((m = regex.exec(raw)) !== null) {
            // Parse each annotation line into an object
            annotations.push({
              level: m[1],
              title: m[2],
              file: m[3],
              line: parseInt(m[4]),
              endLine: parseInt(m[5]),
              message: m[8]
            });
          }

          // Group annotations by root directory → subdirectory → [annotations]
          const grouped = {};
          for (const root of ROOT_DIRS) grouped[root] = {};

          for (const a of annotations) {
            const file = a.file.replace(/^\.\//, ''); // remove leading './'
            const root = ROOT_DIRS.find(r => file.startsWith(r + '/'));
            if (!root) continue;

            const parts = file.split('/');
            const sub = root + '/' + parts[1]; // subdirectory name

            if (!grouped[root][sub]) grouped[root][sub] = [];
            grouped[root][sub].push(a);
          }

          // Helper function: count number of errors, warnings, notices
          function countLevels(list) {
            return {
              error: list.filter(a => a.level === 'error').length,
              warning: list.filter(a => a.level === 'warning').length,
              notice: list.filter(a => a.level === 'notice').length
            };
          }

          // ---------- COMPACT SUMMARY WITH LINKS ----------
          let summary = `# Biome Report Summary\n\n`;
          const ghPrefix = 'user-content-'; // prefix for GitHub anchor links

          for (const root of ROOT_DIRS) {
            const subs = Object.keys(grouped[root]);

            // If no annotations exist for this root directory
            if (subs.length === 0) {
              summary += `**<a href="#${ghPrefix}${root}">${root}</a>** — _No issues_\n`;
              continue;
            }

            // Root-level counts (sum of all subdirectories)
            const rootAnnos = subs.flatMap(sub => grouped[root][sub]);
            const rootCounts = countLevels(rootAnnos);

            summary += `**<a href="#${ghPrefix}${root}">${root}</a>** — ❌ ${rootCounts.error} ⚠️ ${rootCounts.warning} ℹ️ ${rootCounts.notice}\n`;

            // Subdirectory counts (one line each)
            for (const sub of subs) {
              const c = countLevels(grouped[root][sub]);
              const subId = sub.replace(/\//g, '-'); // safe anchor ID
              summary += `&nbsp;&nbsp;• <a href="#${ghPrefix}${subId}">${sub}</a> — ❌ ${c.error} ⚠️ ${c.warning} ℹ️ ${c.notice}\n`;
            }
          }

          summary += `\n---\n\n`;

          // ---------- DETAILED REPORT ----------
          let md = summary;

          md += `# Detailed Biome Report\n\n`;
          md += `**Legend**\n- ℹ️ Notice\n- ⚠️ Warning\n- ❌ Error\n\n---\n`;

          for (const root of ROOT_DIRS) {
            const rootId = `user-content-${root}`;
            // Markdown header + inline anchor for links
            md += `## ${root} {#${rootId}}\n\n`;

            const subs = Object.keys(grouped[root]);
            if (subs.length === 0) {
              md += '_No results_\n\n';
              continue;
            }

            for (const sub of subs) {
              const subId = `user-content-${sub.replace(/\//g, '-')}`;
              md += `### ${sub} {#${subId}}\n\n`;

              for (const a of grouped[root][sub]) {
                const icon = levelIcon[a.level] || '';
                const linkLines = a.line === a.endLine
                  ? `#L${a.line}`
                  : `#L${a.line}-L${a.endLine}`;
                const link = `https://github.com/${repo}/blob/${branch}/${a.file}${linkLines}`;
                const label = a.line === a.endLine
                  ? `${a.file}:${a.line}`
                  : `${a.file}:${a.line}-${a.endLine}`;

                // Detailed line for each annotation
                md += `- ${icon} \`${a.title}\` in [${label}](${link}) — ${a.message}\n`;
              }
              md += '\n';
            }
          }

          // Write Markdown to GitHub step summary (renders in Actions UI)
          if (process.env.GITHUB_STEP_SUMMARY) {
            fs.writeFileSync(process.env.GITHUB_STEP_SUMMARY, md, { flag: 'a' });
          }

          // Print to log
          console.log(md);

          // Fail workflow if any errors were found
          if (annotations.some(a => a.level === 'error')) {
            console.error('Biome found errors, failing job.');
            process.exit(1);
          }
          EOF