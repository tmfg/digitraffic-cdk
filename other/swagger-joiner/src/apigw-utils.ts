/* eslint-disable dot-notation */
import {
  APIGatewayClient,
  CreateDocumentationVersionCommand,
  type DocumentationVersion,
  type ExportResponse,
  GetDocumentationVersionsCommand,
  GetExportCommand,
} from "@aws-sdk/client-api-gateway";
import { logger } from "@digitraffic/common/dist/aws/runtime/dt-logger-default";
import type { OpenApiSchema } from "@digitraffic/common/dist/types/openapi-schema";
import { isObject } from "es-toolkit/compat";

export async function exportSwaggerApi(apiId: string): Promise<ExportResponse> {
  const exportCommand = new GetExportCommand({
    restApiId: apiId,
    exportType: "oas30",
    stageName: "prod",
  });

  const apigateway = new APIGatewayClient();
  return apigateway.send(exportCommand);
}

interface DocumentationVersionResult {
  readonly apiId: string;
  readonly versions?: DocumentationVersion[];
}

export async function getDocumentationVersion(
  apiId: string,
  apigateway: APIGatewayClient,
): Promise<DocumentationVersionResult> {
  const getDocumentationVersionsCommand = new GetDocumentationVersionsCommand({
    limit: 500,
    restApiId: apiId,
  });

  const result = await apigateway.send(getDocumentationVersionsCommand);

  return {
    apiId,
    versions: result.items,
  };
}

export function createDocumentationVersion(
  apiId: string,
  latestVersion: number,
  apigateway: APIGatewayClient,
): Promise<DocumentationVersion> {
  logger.info({
    method: "APIGWUtils.createDocumentationVersion",
    customApiId: apiId,
    customLatestVersion: latestVersion,
  });

  const updateApiCommand = new CreateDocumentationVersionCommand({
    restApiId: apiId,
    stageName: "prod",
    documentationVersion: (latestVersion + 1).toString(),
  });

  return apigateway.send(updateApiCommand);
}

/**
 * Recursively walks a schema object and transforms broken `anyOf: [schema, null]`
 * or similar oneOf structures generated by API Gateway back into a valid OpenAPI 3.0 format
 * with `nullable: true`. This function mutates the object.
 * @param schema The schema object to fix.
 */
export function fixApiGatewayNullable(schema: OpenApiSchema): void {
  if (!isObject(schema)) {
    return;
  }

  const toVisit: Record<string, unknown>[] = [schema];
  const visited = new Set<unknown>();

  while (toVisit.length > 0) {
    const current = toVisit.pop();

    if (!isObject(current) || visited.has(current)) {
      continue;
    }

    visited.add(current);

    // Determine if the current object has a broken `anyOf` or `oneOf` structure
    const compositionKey = ["anyOf", "oneOf"].find(
      (key) =>
        Array.isArray(current[key]) &&
        (current[key] as unknown[]).length === 2 &&
        (current[key] as unknown[]).includes(null),
    );

    if (compositionKey) {
      const schemaPart = (current[compositionKey] as unknown[]).find(
        (x) => x !== null,
      ) as Record<string, unknown> | undefined;

      if (isObject(schemaPart)) {
        logger.debug({
          message: `Fixing nullable field with ${compositionKey}: ${
            JSON.stringify(current)
          }`,
        });

        // Delete the broken anyOf
        delete current[compositionKey];

        // Merge the properties from the actual schema part
        for (const key in schemaPart) {
          if (Object.prototype.hasOwnProperty.call(schemaPart, key)) {
            current[key] = schemaPart[key];
          }
        }
        // Add the correct nullable property
        current["nullable"] = true;

        logger.debug({
          message: `Fixed nullable field ${JSON.stringify(current)}`,
        });
      }
    }

    // Find nested objects/arrays to visit next
    for (const key in current) {
      if (Object.prototype.hasOwnProperty.call(current, key)) {
        const value = current[key] as Record<string, unknown>;
        if (isObject(value) || Array.isArray(value)) {
          toVisit.push(value);
        }
      }
    }
  }
}
