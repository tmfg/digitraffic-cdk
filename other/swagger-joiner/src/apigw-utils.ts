/* eslint-disable dot-notation */
import {
  APIGatewayClient,
  CreateDocumentationVersionCommand,
  type DocumentationVersion,
  type ExportResponse,
  GetDocumentationVersionsCommand,
  GetExportCommand,
} from "@aws-sdk/client-api-gateway";
import { logger } from "@digitraffic/common/dist/aws/runtime/dt-logger-default";
import type { OpenApiSchema } from "@digitraffic/common/dist/types/openapi-schema";
import { isObject } from "es-toolkit/compat";

export async function exportSwaggerApi(apiId: string): Promise<ExportResponse> {
  const exportCommand = new GetExportCommand({
    restApiId: apiId,
    exportType: "oas30",
    stageName: "prod",
  });

  const apigateway = new APIGatewayClient();
  return apigateway.send(exportCommand);
}

interface DocumentationVersionResult {
  readonly apiId: string;
  readonly versions?: DocumentationVersion[];
}

export async function getDocumentationVersion(
  apiId: string,
  apigateway: APIGatewayClient,
): Promise<DocumentationVersionResult> {
  const getDocumentationVersionsCommand = new GetDocumentationVersionsCommand({
    limit: 500,
    restApiId: apiId,
  });

  const result = await apigateway.send(getDocumentationVersionsCommand);

  return {
    apiId,
    versions: result.items,
  };
}

export function createDocumentationVersion(
  apiId: string,
  latestVersion: number,
  apigateway: APIGatewayClient,
): Promise<DocumentationVersion> {
  logger.info({
    method: "APIGWUtils.createDocumentationVersion",
    customApiId: apiId,
    customLatestVersion: latestVersion,
  });

  const updateApiCommand = new CreateDocumentationVersionCommand({
    restApiId: apiId,
    stageName: "prod",
    documentationVersion: (latestVersion + 1).toString(),
  });

  return apigateway.send(updateApiCommand);
}

/**
 * Recursively walks a schema object and transforms broken `anyOf: [schema, null]`
 * structures generated by API Gateway back into a valid OpenAPI 3.0 format
 * with `nullable: true`. This function mutates the object.
 * @param schema The schema object to fix.
 */
export function fixApiGatewayNullable(schema: OpenApiSchema): void {
  if (!isObject(schema)) {
    return;
  }

  const toVisit: unknown[] = [schema];
  const visited = new Set<unknown>();

  while (toVisit.length > 0) {
    const item = toVisit.pop();

    if (!isObject(item) || visited.has(item)) {
      continue;
    }

    const current = item as Record<string, unknown>;
    visited.add(current);

    if (
      Array.isArray(current["anyOf"]) &&
      current["anyOf"].length === 2 &&
      current["anyOf"].includes(null)
    ) {
      const schemaPart = current["anyOf"].find((x) => x !== null) as
        | Record<string, unknown>
        | undefined;

      if (isObject(schemaPart)) {
        logger.info({
          method: "SwaggerJoiner.fixApiGatewayNullable",
          message: `Fixing nullable field ${JSON.stringify(current)}`,
        });

        // Delete the broken anyOf
        delete current["anyOf"];

        // Merge the properties from the actual schema part
        for (const key in schemaPart) {
          if (Object.prototype.hasOwnProperty.call(schemaPart, key)) {
            current[key] = schemaPart[key];
          }
        }
        // Add the correct nullable property
        current["nullable"] = true;

        logger.info({
          method: "SwaggerJoiner.fixApiGatewayNullable",
          message: `Fixed nullable field ${JSON.stringify(current)} `,
        });
      }
    }

    // Find nested objects/arrays to visit next
    for (const key in current) {
      if (Object.prototype.hasOwnProperty.call(current, key)) {
        const value: unknown = current[key];
        if (isObject(value) || Array.isArray(value)) {
          toVisit.push(value);
        }
      }
    }
  }
}
